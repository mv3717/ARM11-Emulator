\documentclass[10pt]{article}
\usepackage{fullpage}
\begin{document}
\title{\underline{ARM - Checkpoint Report}}
\author{Gauthier Bonvarlet, Theo Cohen, Sebastian Kovats, Marco Violet-Vianello}
\maketitle
\section*{Group Organisation}
\hspace*{0.6cm} At the beginning, we discovered the specification individually, discussed our understanding and developed a strategy to solve the task. We decided to work together on reading the binary file and establishing a meaningful representation of the 32 bit instructions so we could manipulate them efficiently. Then, since there are four different types of instructions, we saw fit to divide these so that we each had one. Sebastian worked on parsing the 32 bit instructions to determine the type of instruction being processed as well as the section regarding branch instructions. Marco decided to take care of the data processing instructions. Gauthier worked on the implementation of the multiplication instruction and finally Theo would approach the single data transfer instructions. \newline
\hspace*{0.6cm} After this, we established the good practices we should adopt to make sure our individual code was coherent with everyone else's and how we were going to manipulate git to make sure we were all on the same wavelength. After creating our individual branches on the git we steadily worked on our individual parts. For some of our parts, the tasks were pretty straightforward such as multiplication and parsing instructions as well as the basic data processing instructions (mov, add...). However, other tasks were more challenging such as parsing the "Operand 2" as it had several different possible forms and went through one of four elaborate shifts and rotations. Moreover, some of the single data transfer instructions relied on the value of operand two after the data processing instructions which made it difficult for Theo to move forward. \newline
\hspace*{0.6cm} If we had to do one thing differently, it would be that we should have figured out how run the test suite earlier. In fact, our team neglected this for a bit before realising that moving forward by only testing manually would be inefficient. Sebastian was successful in understanding the correctness of the parsing of the instructions through gdb but for Marco, Gauthier and Theo it wasn't as simple. We needed to compare our results to the expected outputs on Konstantinos test suite and because there were over fifty tests, this meant that manually verifying them was inefficient. Therefore, after implementing the basic data processing instructions, Marco decided to start understanding the Ruby code to be able to run the tests so that the rest of the team could test their functions and be able to debug as soon as possible. It was challenging for the team to get the printing of the output exactly in the same format as the outputs of the test suite because these required an extensive knowledge of the different "printf" syntaxes and the fact that a single difference of character would cause all the tests to fail. When we were able to run the tests, it was immediately easier for us to judge how well the project was going and what the remaining parts were. Everyone was able to correct the occasional errors they had in their code using the test suite. \newline
\hspace*{0.6cm} Finally, when we all debugged as much as we could individually, we decided to work on the more challenging issues as a group. For example, we worked on the complexity of determining the value of "Operand 2", as elaborated above, in the data processing instructions as it required a well oiled and structured code to be able to process all of its elaborate forms. Additionally, this part needed to function properly so that we could verify the correctness of the single data transfer instructions. \newline
\hspace*{0.6cm} Thus, at the end of Thursday we finished part one with all tests passing a full day before the deadline giving us time to make sure it was well structured, perfectly indented, sufficiently and accurately commented and overall "beautiful" code.
\section*{Implementation Strategies}
\hspace*{0.6cm} We think that we are effective overall as a group. The challenging but most rewarding part so far was starting the project to be able to start working independently. Hence, we worked as a four to build a solid base. We had the basic functions and established the practices we would adopt to ensure consistency when we starting working on our individual parts. We co-ordinated well to merge branches frequently and verified that progress from different branches was correctly implemented. The chemistry is great and the fact that we are a group of two Computing students and two JMCs means we have a broad range of skills and knowledge that we can refer to. Furthermore strong communication between the team members allowed us to progress easily and build in symbiosis around to the code others wrote. We intend to keep the same work ethic for the upcoming tasks and learn from the issues we encountered along the way. 
\section*{Emulator Structure}
We split the emulator into 6 files:
\begin{itemize}
\item main.c: The entry point of the program handles parsing the input arguments and reading in the binary file as an array of 32-bit data chunks. The chunks are then processed in the main pipeline loop, which delegates to executor.c.
\item Executor.c: Here the execute function checks for the type of instruction and whether it is valid according to the condition bits. It then delegates to the relevant functions for data processing, multiplication, branching and data transfer.
\item Data\_processing.c: Since data processing is actually many different instructions we decided to put these functions in a separate file.
\item Typedefs.h: Here we define various data types for use in the program and model the state of the machine as the struct Registers, which is passed to all functions that manipulate it.
\item Tests.c: We used this file to place debugging functions which print information according to a given instruction, such as its type and source/destination registers. This turned out to be invaluable in later stages of development.
\end{itemize}
\section*{Future Challenges}
\hspace*{0.6cm} Now that we have successfully completed part one of this assignment, we are looking at what needs to be done in part two. We intend to continue and build upon what we have learned in part one as elaborated above. 
Looking at part two, we have chosen to adopt two-pass assembly because splitting the tasks will be more evident (there are four operations, like in part one) and also because single-pass assembly seems to cause further challenges as elaborated in the specification. 
In addition, we see that a significant part of this task relies on what we have done in part one: the instructions, their format and the manipulation of bits through the use of bit masks and shift operations.
Moreover, we must continue to be rigorous to how we process the input and our variables by being attentive to details such as the fact that ARM stores instruction and data words using a little-endian encoding.
On another note, we intend to extensively use our knowledge of assembly developed in the architecture module to process the assembly instructions as efficiently as possible.
\end{document}
